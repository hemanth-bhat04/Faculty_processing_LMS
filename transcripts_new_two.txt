Okay, okay, okay. Uh-huh.
Okay, okay.
Okay, good morning, everyone. Good morning, ma'am. Good morning. So, are you able to do the assignment questions? Yes, ma'am. Okay. Please, please take my case if you are able to do it. Yes. Okay. Today, in the afternoon, you will be having the discussion session. Okay? They will be asking you to share your screen and execute the code. Okay? So, Shilpa madam will be taking it today in the afternoon. Shilpa madam will take it at 4 o'clock. So, what about the tool—is it comfortable? Oh, working on that, ma'am. No, that tool—is it comfortable? Means, do...
In that, yeah, we cannot open one more tab, ma'am. Actually, it is showing us one more tab. This means that if a designer is there, we have to work on that. If you try to open one more, it should show an error. "One more" means you want to add a file, or I add it while compiling, ma'am. The history will be there, and it will get executed for the other one. Yes, ma'am, like the previous one will be executed. Yeah, I think we have to separate them because you are not using the particular instance, so there is no need for that. That's why you are getting the error. For the design tab, we are not able to close it. You cannot close it, yeah. So that's why you don't need to create a new design and open it. Instead, you have to go to the right side and click it. The new window will start getting executed. In that case, they are executing it, which is why they are getting...
Data flow modeling. Okay, so in the afternoon, you'll be having a discussion of yesterday's assignment. Ma'am, yes, ma'am. Do we need to write the assignment on a notebook, or just here only? Can you please speak louder; I'm not able to hear. Ma'am, I'm asking—do we need to write the assignment on a notebook, or no? What you can do is take a picture of this. Okay, uh-huh. And paste it into a Word document, and make it a PDF. Okay. And for theory questions, I will just write the answer. Right? Theory questions—whatever is there, no, just write down the answers—one A or two A, like that. Okay, okay, ma'am. Ma'am, thank you. Okay. That you have to upload the assignments. Okay, okay. For that, results—no, yeah. I want the waveform pick also, with the design code, test bench code, and the waveform in the assignments. Ma'am, when we download this file... okay.
We are getting a test batch and `data_design.sv`. Yeah, all the files you will get when you download. Do we also get the waveform window? No, the waveform window won't be there, so we need to take screenshots of that already. You can take a screenshot—no, mhmm, okay, okay. Print screen or a screenshot—you take and paste it into a Word document, okay, ma'am? Okay, so we'll start with today's class. Today, I will be going through the switch-level modeling operators and the data-flow modeling. Okay, so first, we'll start with the switch-level modeling. Switch-level modeling is implemented using transistors and is used to describe small-distance systems like AND gates, NAND gates, OR gates, and up to MUXes. You can use these, okay? But for complicated...
It is very difficult to use switch-level modeling, so this is usually implemented in VLSI circuit layers. This is the lowest HDL logic level description. Okay, so after the switch level—since this switch level is rarely used—we move to the gate level, which is commonly used. Okay, so the switch level is the lowest level. After the switch level, we have the gate level, then structural, then data flow, and the highest level is the behavioral. Okay, so let's take the inverter example. I have this one inverter. You've come across this diagram with the transistors in your VLSI subjects, right? You have a PMOS and an NMOS, right? Here, this is the inverter, with "in" as the input and "out" as the output. So, when we write the switch-level diagram, we have a PMOS and an NMOS.
Just a minute. Someone has logged in. Okay, so here we have a supply of one for VDD and a supply of zero for ground. Then we have to write a PMOS and an NMOS. Okay, so it was like this, right? So, this is my NMOS, and this is my PMOS. This is ground, and this is my VDD. Okay, so here is my output. In this code, the output is taken as `y`. And this is the input, which is taken as `a`. Okay, so for the PMOS—okay, so the PMOS is already built-in. We just have to call that PMOS name, like your gate primitives. Then you have an instance.
Name. Okay, so after the instance name, we have to give the ports. So here, you have an order: First, we have to give the drain, source, and the gate. This is the order: First, you have to give the drain, source, and the gate. Here, when you go to this PMOS, Y is the drain, VDD is the source, and A is the gate. Similarly, for the NMOS, first, you have the drain, source, and gate. NMOS is a keyword, then you have the instance name. So, Y is the drain, ground is the source, and A is the gate. Okay, so here, in the switch-level modeling, the order is important: That is, drain, source, and the gate. Like in your primitive gate premises, you told that the output should be the first and the input should be the second. So, in a similar way, in...
Switch-level modeling has the order: drain, source, and gate. For the inverter using PMOS and NMOS, we have built it. We have to give predefined words for the higher voltage supply (one) and the supply zero (ground). Then, I have PMOS and NMOS. For the PMOS, Y is the drain, VDD is the source, and A is the gate. For the NMOS, N1 is the instance name, Y is the drain, the ground is the source, and A is the gate. Then, we'll end up with the `endmodule` statement. Now, for this, if you write a testbench, okay? I have a module named `tb_inverter`, with `reg a` and `wire y`. Then, I have an inverter instance named `n1`. I have a connection between `y` and `a`. In the `initial` block, I have `dumpfile("dump.vcd")`. Then, I have given `a = 1'b1`. Since `a` is a single bit, okay? As `a` is a single bit, directly...
Then, when you are making the connection, there is no need to write the range directly. If you write `a` in the brackets, that is enough. Actually, I didn't give `0 downto 3` for `a`. No, no, no—that is wrong. That's good; it will give an error. Okay, yeah, ma'am. I'm getting errors. Yeah, that's fine. So, anyway, you have declared how many bits and the range you have mentioned. Yeah, ma'am. Yeah, ma'am. Just make sure you do the port mappings correctly. Ma'am, but if I give `4 downto 3` in the design part and I just give `a` in the test bench, and then I try something like `a.a(0)` or `a(0)` in the test bench, no—that won't work. Because the number of bits will mismatch. So, either you will get an error, or it will take only the single bit value.
Okay. Either it will show an error or it will give some problem. It will take only a single value, like the last MSB or LSB value. It will take that. Yeah, okay. Okay, thank you. Welcome. So again, who has raised their hand? Ma'am, yeah, Pankaj. Ma'am, in that test bench—in case of switch-level modeling, okay, at the switch level, we can only give 0 or 1. No, ma'am. It means the values—it will already take a single value because, whether it’s PMOS or NMOS, it depends on the logic. You have to give single values. So for that, secondly, it is the very lowest level. Yes, ma'am. Multi-bit values are not allowed. No, multi-bit values are not allowed. But if you want to write the diagram for multi-bit values, like your example of ripple carry and all, so you have to, ma'am. I have to, in that case, provide each input separately. Yeah, separately, you have to provide them.
Separately, you have to take the PMOS and NMOS. Yes, ma'am. That will be very complicated. Yes, yes, ma'am. So, for that reason, we say that the switch-level model is the lowest level. Mhmm. Yes, ma'am. Due to those reasons, we have different modeling approaches. There are some drawbacks with these models, so we define different levels of modeling. Okay? So, any doubts? Others, if you have understood, please let me know. Okay? So, next, I will draw the diagram. I want you to tell me. Okay? So, next, I have a two-input NAND gate. This is my NAND. Okay? So, here, when we are writing a NAND gate, we have a PMOS in parallel and an NMOS in series. Okay? So, here, we did it. These are the...
Source and A, B are the gates for the PMOS, and OUT is the drain. So, here, in this NMOS, OUT is the drain, A is the gate, and S1 is the source for the first NMOS. For the second NMOS, ground is the source, S1 will become the drain, and B will become the gate. Okay? So, in the PMOS, the source, gate, and drain are VDD, and A and B are the gates, while the output is the drain. In the NMOS, since it is in a series connection, OUT is the drain, A is the gate, S1 will become the source in the case of the first NMOS, and in the case of the second NMOS, S1 will become the drain. Okay? Then, B is the gate, and ground will be the source. So, now, how can I write the code for this? So...
So, anyone—if you can answer it—so we need two PMOS transistors, two PMOS, and two NMOS transistors. Okay. On one side, in between, we are taking `apmos` and `bpos`. Okay. What I have to declare here? Yes, ma'am. Okay. So, first—okay, first, you tell me about the first PMOS. The first PMOS source—we did that. Okay. In between, your so—and the drain is this one. Okay. So, first, what I have to write: `vdd` or `s1`? `s1`, okay. So, this has to be `s1`. Okay.
Okay, so here you have to properly give the names. And one more thing: I had told you yesterday about the dollar display. If I don't address this delay, okay? So I will run this, and you can see the first initial values. Someone has put "ma'am," but there's an issue. I'm leaving now. Okay, I'm not able to... Just a minute. I will make the settings of the profile so that I can get the EP waveform in a separate window. It is overlapping.
Yeah, it needs some delta time to get updated. Okay, so for that reason, we are giving some delays, and then we are giving the display statements. Okay, so you have to be aware of that. This is the inverter code. Okay, can you write the code for NAND and NOT gates? NAND, NOR? Yes, ma'am. Or do you guys want me to show those things? We can do that, ma'am. I have a doubt. Yeah, test bench, test bench. Okay, yeah, you can ask about the whole thing, ma'am. Which one? How to create a test bench? Output? How to create a test bench? How to create the test bench? Yes, ma'am. So, how to create the test bench—so now I will remove this one, so...
Also, it will change `a`, `b`, and here, the port mapping will also change. In a port design, if you have any wire, and if it happens to be used in the test bench code, should it be taken as a wire or a register? So, you mean, if you need some other variables in the test bench, yes, yes, yeah, that will be written as a `reg`. Okay, okay. So, sometimes, using loops, you might write something like this. I told you earlier: for a NAND gate, we'll be using `s1` as a wire. Yeah, yeah. So, that will do. We'll consider that. You'll write only in the design part. In the design, you'll...
Writing here via, yes—one in the test bench. That—that is not a port, right? Yes, that’s not a port. It is not a port; it is the connection inside your code, the design code. So, only in the design will it come as `wire s1`, but in the test bench, you won’t do anything here because `wire` is driven by the gates, right? We won’t assign a value to that one. Okay, okay, okay. So, the `s1` value will depend on this PMOS and the NMOS, right? Yeah, yeah. For that set, we won’t give it in the test bench. So, in the test bench, only the external ports are there. Now, for the design, only for those will we give the values. Okay, ma’am. Thank you. Yeah, so—is there any… yeah, ma’am? In the midterm, how will we give the inputs, ma’am? For a four-bit… If you are having four…
Yes, ma'am. Yeah, I understood everything now. Understood. Okay. So, for now, I want you to write the code for those NAND and NOR gates. Okay. Later, okay. So, I will go further, ma'am. Yeah. Hello, yeah, Pankaj ma'am. I want to ask something else. When I was running the program, it was showing an "implicit net declaration" error—an "implicit net declaration" error. So, for which variable, ma'am? Actually, in the last question, I have one `f2`. It's from the last day's assignment. The assignment will take place in the afternoon. Okay. Okay. So, if at all you are getting an "implicit wire" error, maybe some wire declaration is missing. No, I declared everything. I declared everything.
Okay, so what about `b`? It is zero now. Before performing the operation, it will check for this value. What is the `a` value? Okay, so the `a` value is 13. Since it is greater than zero, okay, it will check and compare it with zero. Okay, since it is greater than zero, it will convert it into a single bit. If it is greater than zero, it will make it as `true`, which is 1. Okay, so for `b`, it is equal to zero, and it will make it as 0. So here, I have a `true` and a `false` condition. When I apply a logical AND, okay, `true` AND `false` will result in `false`. Okay, so if you are working with single bits, there is no problem. If the value is 4 bits, 5 bits, or more, it will check and compare it with zero. If it is greater than zero, it will treat that value as a `true` condition. If it is equal to zero, it will treat it as `false`. Okay, so here, in...
Operation. If I apply a logical OR, then `true` AND `false` will give you a `true` value. Ma’am, then `1 1 0 1` AND `0 0 1 0`—the output will be `1`. Yeah, if you have, say, `b` instead of this zero value—if you have different values, like if I have `0 0 1 0` AND `0 0 1 0`, so this value is 2, which is greater than zero, right? So it will treat it as a `true` condition. So it is not the value itself—it is greater than zero, meaning it is treated as `1` itself. Okay, okay, okay. If at all you have any unknown values in between, okay—for example, if I have `1 X 0 1`—so you don’t know what the value of `X` is. So this is taken as `X`, and this is `0`. Now, any operation with `X` will give you a result as `X`. Okay, if you need any bit in the vector...
Okay, I will go to the next operator. The next is a bitwise operator. So, bitwise operators are used to perform logical operations on individual bits. Okay? So, like a single bit. In a logical operator, it is converted into a single bit, and the operation is performed. Here, "bitwise" means all the bits are considered. So, in the bitwise operator, you have bitwise AND, bitwise OR, negation, bitwise XOR, and bitwise XNOR. Okay? So, here, I have an example: `a = 1101` and `b = 1100`. Okay? So, here, it will perform the operation bit by bit within the vectors. So, here: `1 AND 0` gives `0`, `0 AND 0` gives `0`, `1 AND 1` gives `1`, and `1 AND 1` gives `1`. So, all the bits are used for the...
Operation. Okay. Similarly, for the logical OR, `1 1 0 1 | 1 1 0 0` means I will get `1 1 0 1`. If I take the negation of `a`, negation of `1 1 0 1` means all the bits will be negated, so it will become `0 0 1 0`. This is called the bitwise operation. You should not get confused—double ampersand (`&&`) for sentences is logical AND, and single ampersand (`&`) for sentences is bitwise AND. Okay? So, any doubts here? Please ask. Any doubts? Yeah, in the input, if it is `1 1 X 1`, then what will be the output? `1 1 X 1`. Okay? One more...
`x` with the zero—it should be zero for bitwise AND or for logical AND as well. It should be zero because, if any of the inputs of an AND gate is zero, it will always give a zero output only. Ma'am, okay. You check in the tool. Okay. Go to the tool. Okay. Okay. In that, you write some module and give `a` and `b` values, and give some unknown values, and check it. Okay. Do you check it? What value will you get? Okay. Okay. You check and tell me whether you'll get this value or here you'll get zero. Okay, ma'am. Okay. Yeah. So, in tomorrow's class, you tell me what way it will be. Sure, ma'am. Okay.
A single bit, but bitwise, it depends on the number of bits which are present in the inputs. Okay. Similarly, you can give for the NOR, so like negation NOR. So, for values, the same values—I will take `1 | ~1`. Again, negation NOR—what is that? `1 | ~1` is `1 | 0`. So, again, negation NOT `1`, so these two NOR means it is `0`. Again, `0` and `1` NOR means it is again `0`. `0` and `1` NOR means `0`. And `1` and `1` with a NOR means I will get it as `0`. So, it will start from the right side. Okay. Bit by bit, it will do within the input. Okay. And it will give a single bit output. So, logical, bitwise, and reduction—these three are very...
One, and the output of the previous step—okay, okay. That is one. Got it. One, and the previous one—it is one. Okay. It will take the previous result of two bits. Yes, ma’am. Yes, ma’am. Okay. So next, we have arithmetic operators. So the first three are very important—okay. Make a note on those three things. Arithmetic operators: here, you’ll have two operands—okay. So we have addition, subtraction, multiplication, division, modulus, and minus—okay. Let me take an example here. So I have `a`, which is `01`. `b` is `111`. `c` is `010`. Now, if I take `a + a`—okay, `01` and `01`—I will get `10`. Okay.
If I do subtraction for `b` and `c`, `b` is `111` and `c` is `010`. So if I do the subtraction, I will get it as a value of five, which is `101`. So if we want to do multiplication, what I will take is a multiplication operator, which is `*` (star). Okay, if I consider it like this, what is the `a` value? That is `01`, which means it is `1`. So `1` multiplied by `2`, I will get the result as `2`. So if in binary, it is `10`. Okay. Similarly, for division, you’ll get a quotient, and for modulus, you’ll get a remainder. So for your assignment, it is minus. So how can you use this minus? Hint: I will give. So, for example, in your normal decimal values, if I give `10`...
Plus minus of five. Now, this "minus of five," okay? This will be your unary minus. Okay, so these are the arithmetic operators. I want you to try all these operators in the tools, okay? Use different values and check them, okay? Next, we have a relational operator. In the relational operator, it is used to check whether it is greater than, less than, greater than or equal to, or less than or equal to. Okay, so here, in the relational operators, we need two operands, and this relational operator will also produce a single bit, either true or false. Okay, if any of the operands have `x` or `z`, the output will be `x`. Okay, so if I take...
Example: Here, I have `a = 01`, `b = 7`, and `c = 2`. So, if I take `a < b`, what is the value of `a`? It is `1`. And what about `b`? It is `7`. Is it true that `a` is less than `b`? Yes, so it is true. I will get it as `1`. If I take the next example, `b < c`: `b` is `7`, and `c` is `2`. But this is wrong, right? `b` is not less than `c`. So, for that sake, I’m getting it as `0`. Okay, so if at all you have any unknown bits here, like `1` followed by an `X` in `b`, okay? If I do any operation with this, I will get it as `X`. So, if I take `a < b`, `a` has a value of `1`, but what about `X`? The total value of this is unknown. So, for that sake, I’m getting it as an unknown value. Okay, so just a minute—I will...
Greater or equal, lesser or equal. Okay, so these are the relational operators. Then you have the equality operator. In the equality operator, we will be used to compare two operands, and this also will produce a single bit—either true or false. Okay, so here, in the equality operator, you have two types: logical equality and case equality. When I go to logical equality, okay, so if at all you are having `X`, if any one of the bits is `X`, then it will give it as an `X` value. Logical equality will check only for `1`s and `0`s. It will not check for `X`; it will give it as unknown. In case equality, it will consider both `X` and `Z`. If any of the bits are `X` or `Z`, then it will compare and give the outputs. Okay, so the case equality operator will never...
Will produce the output as `1`, okay. So, the logical equality (`==`) will consider only the `0`s and `1`s. For `x` and `z`, it will give it as `unknown`. For case equality (`===`), it will consider both `x` and `z`, and it will never result in an `x` value. So, if I take the not-equal (`!=`) operation, `c !=` here also results in an unknown value, so it will take it as `x`. For case inequality (`!==`), if I take it, but these are equal, so for that sake, I will get it as a `false` condition. If I take case inequality, okay, so any doubts in this, ma'am? Here also, it is `case x` and `case x`—two different things. Can you...
Speak loudly, and here, case `X` and case `Z` are also there. Case `X` and case `Z` will come in case statements. Okay, okay. So here, these are the operators. Okay, `K`-6 and `K`-set will come in conditional statements. Okay, yes, ma'am. Yeah, so next, you have the concatenation and replication operators. So what does concatenation mean? You will be combining the bits. Okay, so the concatenation operator is used to combine the bits and group the signals or buses. Okay. Then we have the repetitive concatenation or replication. That means how many times the value has to be repeated. Okay, so how you will be writing...
These two are... So we have a syntax here. Symbols: For concatenation, I have a flower bracket, and inside that, a comma. Within this comma, we have to write the value. Okay, the operands will be two or more. For replication, you have `n` in the flower bracket, comma. `n` means how many times it has to be repeated. You can give the number here. So, for example, if I consider this: I have `a` as `01`, `b` as `11`, `c` as `01`, and `x`. Now, for concatenation, I have in the flower bracket: I have taken `b`, comma `a`, comma `a`. Now, what it will do? `a` means the first two values (LSB), that is `01`. Again, `a` means it is `01`. `b` is `11`. So here, it is the `b` value. The output depends on how many bits you are concatenating. So, for that sake, in this example, I...
Six bits, so the output should be six bits. When you are assigning to any variable, you have to define it as a six-bit value. Okay, so this concatenation combines the number of bits or sometimes signals. Okay, so in the repetition, it means replication. Okay, so here, I have `a` and `b`. Okay, `a` and `b`: first, I have to concatenate them, and then I have a `2`, which means it has to be repeated two times. Okay, `b` means the value is `1'1`. So, I have `1'1` here. `a` means it is `3'b101`. Okay, so now, this concatenated value has to be repeated twice, right? This is once—one time. So, this value is repeated one more time. So, now, how many bits should it be? It should be eight bits—an eight-bit value. So, I have given six bits, but it should be an eight-bit value.
So, you should calculate randomly—you should not give it like this. Okay, intentionally, I made the mistake here so that I have to explain. So, you should calculate, and then you have to mention how many bits it will be. Randomly, you cannot give how many bits, like six bits, eight bits, ten bits, like that. Initially, how to calculate how many bits the value you may get as output? Okay, when you are declaring the outputs, you have to see this concatenation. Only then can you declare how many bits you’ll be getting. Okay, so this is concatenation and replication. Any doubts in this? No, ma’am. Okay. Others? Yes or no? No. Yeah.
So, next, you have a shift operator. In the shift operator, you have a left shift and a right shift. That is, two arrow marks on the right side and the left side. Okay? So here, you need two operands. Okay? So, if we use this one, it is a right shift, and if we use this one, it is a left shift. Okay? So, the empty portion or the empty place will be filled with zeros. Okay? So, if I consider this one—0010—so now, I have 0010. So now, I want to do a left shift by two. Okay? So, two times, I want to left-shift the value. So, in the first shift, what it will do is: This zero will come here, one will come here, and...
Zero will come here, so this zero is neglected. Okay, so now the empty space here will be filled with the zero value. Okay, so in the next shift, this one will go here, this zero will go here, this zero will go here, and the last position will be filled with zero. So now, this is the second shift. Now, okay, so as I was asked to perform two shifts, I am doing two shifts. So now, you can see the value of `a` is here: `2`, right? What is the value of `a` here? What is the value of this one? Eight. So, for one right shift, you’ll be having a multiplication of two. Okay, so any value will be multiplied by two. So here, for the first shift, it will be `4`, and for the second shift, it is `8`. So, for the left shift, the value will be multiplied by...
Three times like this for the right shift and three times like this for the left shift. Okay. I want to use these things, and I want you guys to check in the tools. Okay. So, this is the shift operator. The last operator is a conditional operator. So, the conditional operator is used to choose one of the values between two values, according to the condition. So, you have a syntax here: that is a condition. You have to view it. If that condition is true, you have to give some value. Yes, if it is false, it has to take some other value. So, it is a condition expression, a true expression, and a false expression. This is the conditional operator. You need three operands. So, for example, you can write a multiplexer...
So, in the 2-to-1 MUX, if the select line is 0, I will get the output as A. If the select line is 1, I will get it as B. Right? So, how can you write this? So, if YES is 0, meaning... I will write the output, which is OUT. So, I will equal SELECT—if SELECT is 1, that is true, I will take it as B; otherwise, I will take it as A. Okay? So, you can write a MUX using operators as well. When I use this method, I need to use some assignment statements. Okay? An assignment statement is nothing but a data-flow modeling approach. Okay? You have to use the `assign` keyword. Okay? If we consider your specification as...
Because we need either `true` or `false` in behavioral modeling. Okay? And in bitwise operations, we can use them in data flow modeling. Okay? All these operators are used for writing different modeling styles. So, for structural, gate-level, and switch-level modeling, there is no need for operators. Okay? Just, we should know the data types and the primitive gates, and how the connections will be made between the components. So, for data flow modeling and behavioral modeling, you need operators. Okay? So, next—one. So, the precedence—okay. First priority in the operators is given to parentheses and bit selection. So, you know, in your C language and other programming languages, the...
Priority will be given to the values which are inside the brackets, right? After that, the operations done outside the brackets will be performed. The next priority is given to logical negation and reduction, followed by addition and subtraction (arithmetic). Then, I have concatenation and replication. After that, you have arithmetic shift, relational, equality, bitwise, and finally, conditional, which is the last one. For example, if I consider `a + b`, and then inside the brackets, if I take the negation of `c`, so what it will do is first it will go to the brackets and perform the negation of `c`. That value I will consider as `zed`. Sonali is in waiting.
Then, it will do this one. I think here, whether it is left to right or right to left doesn’t matter. Yes, ma’am. Ma’am, it will matter. Ma’am, I mean, so it’s just a simple expression—if you take a guess, it takes complex inspiration, it will matter. If both have the same priority, yeah—if they have the same priority, then it will matter. But here, the priorities are different—the operators are not having the same priority. No, but in case if there is an example, right? Now, you have parentheses and you have two operations like inside the bracket, so which one you’ll perform first? So, if I do this one, yes, ma’am, I have `+10 + 2` in between some other operations, also, right, ma’am? It matters, ma’am. Left to right and right to left—right? First, it will do the bracket operations. Mhmm, so first, it will do this bracket operation, yeah—it will perform the bracket operations. But after...
That some other operations also—if there are some other operations, then it will matter, like we are tracking from left to right or right to left. So, we’ll try and check it—we can verify only using the tool. Okay, using the tool, we’ll verify that. Okay, okay. So, is someone in the waiting room? Yeah, so what do we have to check? We have to check the operators with unknown values, right? So, logical NOT, logical, I think, bitwise—okay, bitwise with unknown values—we need to check. Then, we need to check with this precedence, okay? These two we have to check. Okay. And also, arithmetic shift...
You need to come up with the automatic shift. So, then, we have codes using these operators. So, you can do the adders. Okay. So, `a + b + c`—I. Okay. You can do the addition. You can generate the adder model. Then, using the conditional operators or any other operators, you can write a mux or design different digital circuits. So, in this address, I have `a`, `b`, `c`, and `i`. Then, the sum is of nine bits. So, along with the carry, you'll be getting it. Directly, you can—instead of using those gates—okay, instead of writing the diagram and all—you can use these operators and perform the addition, like an eight-bit adder. So, for the mux—one way, we saw with the conditional operator. So, the other...
So, what are the hardware components you’ll be getting by using the operator? Okay. So, when I use the plus symbol, I will get it as an adder. When I use AND, like that, you’ll be getting an AND gate. So, when I use a minus, you’ll be getting a subtractor. Sometimes, directly, you’ll get a subtractor, or you will get one input with the NOT gate implemented. Okay? You are—I think you have come across in your logic design, like subtractors, half subtractors, full subtractors. There will be one input along with the NOT gate. Okay? So, it depends on the tool. Okay? The synthesis tool will view that hardware. Okay? So, if I use this conditional operator, you’ll get a 2-to-1 multiplexer. And for double equals, greater than, less than, you’ll be getting comparators. And these symbols you should not...
Get confused with blocking and non-blocking. So, blocking and non-blocking, we’ll see in tomorrow’s session. Here, the comparison operators—the double equals (`==`), greater than or equal (`>=`), and less than or equal (`<=`)—you’ll get them as comparators. So, these are some hardware inferences of the operators. Any questions about operators? So, I will go to the TDF Playground. If I have the operator code which is already done, we’ll see it.
Yeah, I have some operator examples. I just took `a + b` and `b + c`, like this. Okay? So, in the design, I just took it as a module `op`. `reg a, b, result;` Four bits are set to zero. Then I gave some `a` and `b` values, just for addition and multiplication. So, let me do whatever you ask now. I will add here: `c = 4'b1x01`. I will take that. Then, what I will do is `a & c`. Okay? So, I will run this one.
C identifier. Okay. I mean, design—you have written it. Yeah, it is a normal code. No, either you can write it in a design or a test bench. Just we are checking with the operators to see how it will perform. Either it is not a design, not a test bench. Okay. So I think it is given in decimal. Okay. If I take it in binary—I mean, display `c`, ma’am. Okay. `c`—this is `c`. I’ll display it in binary.
So, what is the result? How many bits is it? Five bits. Okay. `a` and `c`—so here, it is `0`. Yeah, what you said is the right thing—that is, `X` with any `0` is taking it as `0` for AND only, ma’am. But for OR, it will take `X`. Yeah, that only. I will now change it. I’ll change it to OR. Yeah, so for `1`, it will take it as...
Now, generally, in tools, the `initial` block is not allowed. I think, in design, yeah—in tools, yeah. So, if I... I will copy this one. No, no. It will provide me a form while writing this in the design bench. Just a minute. It is not written. I mean, I’m testing. It is not never written in the test bench. Only it is written. The `initial` block is not used in design. In designs, we won’t use any `initial` blocks. Actually, here, there is no comparison between design and the test bench. Okay. We will make it as a design and test bench. Okay. Here, if you write in the test bench, then you will get it as output. Okay. You’ll get the waveform in this tool. What it is doing—if you write this `dumpvars` only in the test bench, then only you’ll get it as waveforms. So, this tool—what it will do—the test bench—it will...
Test the testbench separately, design separately, but when we write a code in other tools, okay? Just depending upon this name—depending upon this name, as we don’t declare inputs and outputs, no. Depending upon that, it will consider whether it is a design or a testbench. Miss, in this, like, if you do like adopting operations in the design bench and call it in the testbench, will it work, ma’am? Yeah, that will work, but you should have inputs and outputs. Yes, ma’am. In the design bench, we’ll provide the inputs and then handle them. You can also do that. And one thing more, ma’am—like here, you have considered three down to zero: A, B, C. So, if suppose I take `reg` only for A, B, C, and I provide A with four bits of input—means four bits—will it work?
So, `a` is `7`, `b` is `8`. So, if I make `7 + 8`, it is `15`. `15` into `2`—if I take from the left side, it is `30`. `30`, `15`, `2`, sir, `30`, `30`, `30`, `30` minus `1` is `29`. `29` divided by `6` is `4.5`—decimal, okay. So, let me make this also in decimal. I think you are getting a negative because the result is one bit extra. No, so it is doing from right to left. What's the value? It is showing `23`.
What was it in binary, ma'am? What was the output in binary? In binary, it was `10`. Just a minute—I will display both in binary and in decimal. Both, okay? K. `1011` in binary. So, in decimal, it is `23`. So, if I start from the left, it is `29 ÷ 6`, which is `4`—right? Four point something.
It as a five. So, if I start from the right: Six minus two—it will be minus four. So, B is eight minus two—eight, ma’am. Five minus seven minus two—five, ma’am. Correct, ma’am. Right to left only—right to left—is it correct? Yes, ma’am. Yeah—in from right to left, it will also consider the precedence of the individual operators. Precedence of the individual operators, yes, ma’am. Yes, division first, multiplication then—yeah, then like that. That only I told—not blindly right to left. Yeah, right—not only will it take right to left, but along with that, it will take that table. I’m sure of it. Mhmm—that also will be considered. Yes, ma’am. First division, then multiplication, and then...
I—I—I’m—I’m—I’m.
Zero G is seven, so seven divided by three. So, what will be the quotient? Okay, it is two. So, the answer is the first one. Okay, so I think some of you have written the remainder. Okay, that is modulus. If you write it as one, it is modulus. Okay, the answer is the first one. So, for the second question, C and E values are given as equality—that is, logical equality. So, C is having 1'bx, and E is having 1'bx. So, it will not consider the 'x' values. So, I will be getting unknown—that is, one bit 'x'. The second answer, okay? So, for the second question, the answer is the second one. So, next, the third one: A is 0, and B is 1. So, I’m asking whether A is greater than B or not. So, A is greater than B—no, it is false. So, the answer is the third one—that is, 0 (one bit 0). So, for the fourth...
Okay, so the next question is now it is a bitwise XOR. Okay, so it is a bitwise XOR. So, now here, the answer is `11` for the last MSP value, which is `11`. This means the XOR operation is `0`. Then, I have an unknown `X`. Then, `11` means `0`, and `10` is `1`. So, the answer is the first `1`. Okay. So, next, the seventh question: that is left shift by two. So, it is the last four bits: `1000`. It is a left shift by two of `C`. Okay. So, the answer is the last. Then, the eighth question: `D` has to be shifted right side eight times. So, you'll get eight times, which means all zeros.
This is the end operation. So, this is for the half adder. We’ll be using the `assign` keyword, and you’re writing the outputs. One more thing: when you are using the `assign` keyword, `s` and `c` should be of a `wire` type. By default, it will be of a `wire` type, right? So, you should not make it as a `reg` type—it should be of a `wire` type. Okay? For `assign` statements, it should be of a `wire` type. Also, we call these `assign` statements as **continuous assignment** statements. Whenever there is a change in the `a` and `b` values, it will continuously assign the output to `c`, `s`, and `nc` here. Okay? So, we are using the `assign` keyword, so the output should be of a `wire` type. Again, so can anyone tell me—for this one, the full adder?
This we will have a statement that is `assigned a ^ b ^ c`. Sorry, `a ^ b ^ c` for the sum. Okay? For the three AND gates, for the first AND, it’ll be `assigned` to any `wire` type. Any `wire` we can give, like `w1 = b & b & a & c`. Correspondingly, we’ll write it for the other AND gates as well. After that, we would have given the output of each AND gate as a `wire`, so `w1`, `w2`, `w3`. So, for the carry, it will be `carry = w1 + w2 + w3`. Assigned. No, here it is not `w2`, ma’am—all operations. So, it should be the parallel pipe, yeah, the pipe. Okay, ma’am. We can do directly like `assign` to directly. If you want, you can write `a ^ b ^ c`. Yes, ma’am. Okay, okay. That time...
That sum and carry you have to split and write. Otherwise, you have to take one bit extra for the sum for carry indication. Yes, ma’am. So, here, I’m having a single bit, right? A single bit for `a`, a single bit for `b`, and a single bit for `c`. So, now, if you use the arithmetic operator `+` for `a + b + c`, then here, instead of this sum, the sum should be offered as two bits. Now, okay? So, it is two bits for the sum. One bit will be included for the sum, and the other bit is for the carry. If you are using arithmetic operators, or if you are using bitwise operators like `^` (XOR), it will be `a ^ b ^ c`. Okay? So, for the carry, it will be `(a & b) + (b & c) + (c & a)`...
`a` and `b`, okay, okay. Then, `r`, `r`, `b`, `a` and, okay, `b` and `c`, `b` that again pipe, then it is `c` and `a` and `a`. Ma’am, I didn’t get that `sum = a + b + c`. This one, so, yeah, that’s why I’m asking you. Exactly, this is according to your logic diagram, yeah, right. So, for this one, okay, truth table, okay, truth table. If you take, okay, `a`, `b`, `c`, okay. If you consider the truth table, that time, you can directly use this one: `a + b + c`. Okay, okay. If you don’t want this diagram directly, you can use arithmetic operators for this. We should assign like a vector form, vector form, for some of these two...
Hand, hello, ma’am. Yeah, yeah, ma’am. Actually, that is what I want to ask—how to give this for all actors. How to use data for... Yeah, that is it. Now, you understood. Can you take any 4-to-1 mux or something like that? So, it will be more of a 4-to-1 mux. Okay? So, 4-to-1 means `a` is of four bits, so that you link. Right? Ranges from three down to zero, right? Okay. So, now, the select line is also for two bits—one down to zero. Uh-huh. Okay. So, what will be the equation for the output of a 4-to-1 mux? You have to write that lengthy equation. You have to write. Yeah, correct. Yeah, that we have tried. Not into...
You have to combine these two so that you have to assign `sum` as `sum[1:0]`. This `sum` will include both the carry and the added value. For example, if `a` is `1`, `b` is `1`, and `c` is `1`, okay? What will you get for `sum`? What is the `sum` value? One moment—I will complete this. What is the value of `a + b + c`? If I give all `1`s, `1 + 1 + 1`, the sum is `1`, and the carry is `1`, right? Yes, ma'am. Yeah. Now, if I assign this `1` to `sum`, which is of two bits, okay? So now, you'll get the output as `11`. At that time, you must understand that the MSB will be the carry, and the LSB will be the sum. Okay, ma'am? Okay. So, someone has raised...
Condition for 4-to-1, for 4-to-1, yeah. We just view two select lines after the question mark. We view the inputs. See here—you can write like this: Output will be equal to—you have to select. It’s not `true` if, yes, `==` okay. Two-bit first select—that is `00`. Okay? Then, question mark—if it is `00`, what value will go as output? Let me take `a` of `0`. I... I... yeah. Yes. That is `:`—this is continuing. Okay. Again, I will check for `==` tick `b`, `01`. Okay? Again, question mark—that time, what value will go? `a` of `1`. Again, `:`...
Yes, `==`. If `yes` is two bits (`1'0`), then `? a[2] :` the last value is what I want. Again, I will check for `yes` directly. I will write `a[3]` like this. It can be written in a nested form, so it is a lengthy process. Ma’am, ma’am, what if I write `s0, s1 ? a : b : c : b`? Can you repeat? If I write like this—comparing to the `2x1` mux we wrote like `a ? a : b`—so I will write it. Whatever you tell, I will write it. Okay, sure. Yes, but this is for the `2x1` mux.
Yeah, three bits. Again, you have to use conditional operators. One thing—yeah, it will be more. No, ma'am. Like, yeah, it will be linear. So, instead of that, another one—any short process. Short process—we will go for behavioral modeling. Behavioral modeling. Yeah. Okay. Okay. So, for that, sir, only the levels of modeling have been increased one by one. Okay. So, in this, can you tell me? Can you write flip-flops here? So, can you write a flip-flop code? Take a... yeah, ma'am. Thing? No, ma'am. Yeah, ma'am. So, it is difficult to write. We—we—we very lengthy, ma'am. Yeah, it would be, but we can write now, ma'am. No—you need a clock here. You have to check with the clock. So, how will you check here? For data, we need an initial block. Must be able to be aware. Always. Always. So...
Always—it will come in a procedural block. So, it is procedural. So, when you use the `always` keyword, know that it becomes your behavioral code. And for clock generation, we also use `initial`, right? Yeah, that I will show in behavioral. Okay. Okay. So, we'll finish up data flow, then we'll go to behavioral. Okay, ma'am. Okay. So, I told you that either you can use these bitwise operators, or you can use the conditional operators, or you can use the arithmetic operators. So, the data flow modeling will be done using the operators. Okay. So, next, we have behavioral. So, you want me to run this code in the tool, or you will do it? We will do it, ma'am. This time, ma'am. Okay. Similarly, for...
Full adder—you can write for ripple carry adder. So, we'll show it, yes, ma'am. Carry adder means you'll be having three full adders, or directly, you can have equations for ripple carry adder. Ma'am, for ripple carry, can we do it like this—directly write it, using the automatic operator? Okay, anyhow, it is in the previous slides. I had shown it. No, yes, ma'am. That will become data—seven bits. I got an eight-bit output—that is a ripple carry adder. Yes, ma'am. So, this one—let me go back. This is a ripple carry adder only. No, so you have—let me take only four bits. Okay, it is having eight bits, so let me have `a3`, `a2`, `a1`, `a0`. Okay, so then, I have `b3`, `b2`,...
Here, I have `b1` and `b0`. Initially, you don't have any carry, so it will be `0`. Okay. So, if you use this, you'll get `s0`. With this carry, it will propagate here. Again, you will get `s1`. This carry propagates here, and you'll get `s2`. This carry propagates here, and you'll get `s3`. The last bit—the extra bit you are taking now here—that will be `s4`. So, ripple carry—you can write using these arithmetic operators. Is that okay? Understood? Yes, ma'am. Yes, ma'am. Yeah. So, we'll go to behavioral modeling. Anyhow, you'll have assignments on this data flow. Okay, so...
Always blocks are the initial blocks, but usually, for the design, we won’t go with the initial block. Why? Because the initial block will be simulated only once—again and again, it won’t be simulated. So, for that sake, we use initial blocks in the testbench, and we use always blocks in the design. Okay? About that—initial and always—you have examples and a discussion in the next sessions. Okay? So, here, in behavioral modeling, just think: In behavioral modeling, you’ll be writing using the always block, and the conditional operators inside it—sorry, conditional statements like `if-else`. Then, you have case statements. Okay? So, in this example, I have a module, the module name, and the ports, then port declarations. And here, in behavioral modeling, you have to declare it as a `reg` type. Okay? That is fixed.
Edge type. So, ma’am, we declare it in the design model only, or in any way—in the testbench, we declare the output as... There is only the testbench; there is no change, even for dataflow. Yeah, dataflow also has no change. The inputs will be declared as `reg` type, and the output will be `wire` type. There is no change in the testbench. Okay. That is fixed in the design. When you go to behavioral modeling, the output should be of `reg` type. Okay. For other modeling styles, it will take the default, which is `wire`. Okay, okay. So, for this 2-to-1 mux, we have a truth table. If `yes` is `0`, I will get whatever is there in `a`. If `yes` is `1`, whatever is there in `b`, I will get it. Okay. So, for that sake, I’m taking `if` conditions here. If `yes` is `1`...
Okay, so the data is not enabled yet. No, ma’am. Data assignment is not enabled. The PPTs are available—PPTs are available. RTL? Yes, ma’am. RTL 389999—that’s available. It is available. Yeah, okay. So, I will ask for data assignment to be enabled. I’ll ask them once again. Well, we are using the same PDF for 380 AD, right? 380 AD is there. So, for 380 AD, the extra things are added. Okay. Then, you must have the ADIDS PDF. ADIDS is there. It is enabled. Ma’am, RTL PRE-ADDED PDF is enabled. The same thing which you use...
No, pre-ADD, not pre-ADD, because for ADD, at last, I have added tasks and functions. Not pre-ADD, no, ma’am. Not available, ma’am. It is not there, no, ma’am. Okay, I will upload, and I will ask them to enable, okay, ma’am. Assignment means RTL assignment will be discussed by Shilpa ma’am. Yeah, Shilpa ma’am will be discussing because I have some extra classes, other classes, okay. Okay, ma’am. Okay, ma’am. Okay. So, if any doubts are there again on Monday, Monday, I will take the discussion session. Monday, I will take it. Okay, okay. That time, if any doubts are there, then we can discuss on Monday afternoon. Okay, ma’am. Okay. So, today, Shilpa ma’am will be taking the session. Sure, meet at four o’clock. Okay.
So, we have a `module` keyword, then I have an `inverter` name, then I have `y`, and for that, I have `in` and `out`. Okay, here, `a` is the input, and I have taken `y` as the output. Okay, just the naming has been changed. So now, `input a`, okay, `output y`. According to that diagram, `in` is the input, and `out` is the output. Okay, so here, in switch-level modeling, we have predefined words for that: `vdd` and `ground`. Okay, `vdd` is a high voltage, so for that sake, we have to use a predefined word called `supply_one`. `Supply_one` is a predefined word for the higher voltage, and `supply_zero` is a predefined word for the ground. Okay, so here, `supply_one` represents `vdd`. The name can be anything; you can use `vss`, okay. But `supply_one` is predefined for a high voltage, so you have `supply_one` representing `vdd`.
I'm using these two lines. Then I have `$dumpbars`. What I will give—I will give a value to A. Either I can do it like this, or you can give one tick: `b = 0`. Okay? So, like this, we are giving some delays. I will keep giving the A values. This is common for every code—we need it. Yeah, every code has this, but depending on the number of inputs, you have to provide that many input values. For the inverter, I have only one input, so I'm giving only the A value. So, if I had a NAND gate, okay, I'd have two inputs. That time, after A, I have to give `b = 0`. Similarly, here also, `b =` some other value, like zero. And the initialization of which one—`reg a, b`, yeah.
And it is also running. For some values, the function gives a "don't care" output, meaning the output is `X`. Output `X` means there won't be any connection in between, and sometimes, a problem will occur. Sometimes, you are assigning two values to that wire. I'll show you. I'll show you in the evening, ma'am. Okay, in the afternoon, we'll discuss the doubts and assignments. Okay, so understood how to write the test bench. So, in between, if you want to display it, you can use `$display` and `$finish`. How to use `$finish`? Okay, so we'll go back to the theory class. We'll start with the operators. So, in the assignment, you don't have any questions on switch level. So, I want you guys to write for a NAND and NOR...
So, there will be confusion with these three. Okay, please make a note: For logical operations, you’ll get a single output. So, even if we are giving multiple bits, it is converted into a single bit, and you’ll get the result as a single bit. In logical operators, in bitwise operations, it will perform the bitwise operation. So, how many input bits there are, that many output bits you’ll be getting. In reduction, you’ll have a single operand. Okay, on a single operand, it will perform the operation. So, then it will do the bit-by-bit operation. Okay, that is starting from the right side. Okay, so any doubts in these three, ma’am? Explain, or ma’am—or, or, or not, or, or, or? Okay, so I have a value that is 1101. Okay, so 1, 0, and 1—what is the OR? One—it is one. So, again, this…
Okay, so if you go to this one, "greater than or equal." Okay, so I have here—let me take B as 011. Okay, C also I will take it as 011. Okay, now, if I do B greater than or equal to C, so this "greater than" will fail because it is not greater. Equal—it will be true. So, for that sake, I will get it as a true value. Similarly, for "less than or equal," okay? So, for "less than or equal," if "less than" is not satisfying, then it will check for "equal." If "equal" is not satisfying, and "less than" is satisfying, then it will give it as a true value. Okay, so these are the relational operators, so they will produce a single bit, either true or false. So, you’ll be having a "greater than," "less than,"...
I will get it as `a` if you consider it like this. Okay. So, when I write using the conditional operator, first is the condition expression. What is the condition expression? I have to check with `a`. Yes, so I will take it as `a`. Yes. So, then comes the question mark. What is the true expression? So, if this `yes` is `1`—means `yes` is true—okay. What value should go as the output? That is `a`. Else, the output should be `b`. So, this one—`out`—I will assign it to my `out`. The true value will be first, right? Yeah, the true value will be the first. Okay. So, for this conditional operator, I have to use the `assign` keyword. Okay. This `assign` will come in the data flow modeling. So, operators will be used in the condition data flow modeling or behavioral modeling. Okay. We'll be using them, but the logical—okay, logical—we take it in the behavioral...
It is similar to all programming itself, ma'am. I’m not sure, that’s why I’m asking. So, here, if I do this—if I get some value here, okay, like `4 * 5`, it is `20`, divided by `5`. Okay, so now, how you will do these things—you’re telling why not, ma’am? I see. Means, if you do it from left to right, the output will change. And if you do it from right to left, the output will get the default value. Okay, so I will get back to you by tomorrow. Okay, sure. Yeah, so I will check and I will get back to you on that. Okay, ma’am. I think so—it is similar to all programming itself. I don’t know—it’s the app, okay. I will check and tell you. Okay.
Divide. Divide means what is the quotient—one divided by six. Okay. It is zero point something, right? Quotient. So, I’ll consider it as a whole number, as zero. Okay. So, it is doing from right to left—is that clear, everyone? It is from right to left. Yes, ma’am. Ma’am, once interchange the division and multiplication operators. Ma’am, interchange the place. Interchange the place. Okay. Here, I will do divide. Yeah. Here, start. Okay. Calculate the value and keep running until I run it. It is starting.
Harshita, yeah, I submitted. Okay, you’re doing it. So, Chitin, submit—we note it’s done, ma’am. Submitted, submitted. Okay, so I think everyone has finished. One person who hasn’t been done—I will send it. Okay, so we’ll end the poll. Okay, we’ll share the results. Is it visible? Okay, yes, ma’am. Okay, so the first one: So, `a` is…
Input. I will take this input. Okay, ma’am. Annotation is not seen. Annotation is not seen. Just a minute. No, yes, ma’am. I’ve seen it. No, okay. So here, I have `X` in one of the bits. So what it will do—if I take some AND operation or `X`, okay—we’ll take AND. So `1 0` means it is `0`. `X` with a `0` operation will always be `X`. `1 1` means `1`. `1 1` means `1`. So now, it will give `1 1 X 0`. It is a bitwise operation. Understood, Tana? Yes, ma’am. Okay, ma’am. I have one doubt, ma’am. Yeah, for suppose there is a “don’t care,” but in case of a bitwise AND, it should be `0`. Which one is `0`?
For every shift, okay. If I go with the right shift, okay. Same value—if I consider `0010`, so if I do one shift, so `1` will come here, `00`, so the empty place will be filled with `0`. So this is `2`, and this is `1`. So here, you can tell that if I do one shift to the right, so it will be divisible by two. Consider if I have `0100`, okay. So this is `4`. Now, if I do one shift, I will get it as `2` here—that is, `4` divided by `2`. Is that understood? Shift operators will do the shifting, and the empty or vacated portion will be filled with zeros. So...
Even in the behavioral model, if there is interconnection here in the model, there is no concept of gates. Okay, okay. Using a truth table directly, we'll be writing. Okay, okay. So, I will stop here. So, yeah, the assignment is enabled. You can go to the assignments. So, the data flow modeling assignments are there. You can go through that and do it. So, you'll have an assignment discussion of yesterday's—that is, gate-level and structural. What time, ma'am? Timing? Timing—four o'clock. Okay, ma'am. Okay, four o'clock. Shilpa Madam will be taking. Okay. Not enabled, ma'am. Ma'am, RTL design PPT will be available or not? I will check it. I have given whether it is enabled or not. I will check and tell you. Okay, okay, ma'am. It is already uploaded. Whether it is enabled or not, I will ask.
Things you can use the bitwise operator. Now, in this, I have a single bit, but if it is having two or three bits, so at that time, if you use logical AND, it will—that is the wrong way—it will give a single-bit output. So, here, in dataflow modeling, we’ll be using bitwise operators. Okay, so `A` and `YES`. For example, your equation is `Y = A'S + B'S'`. If it is like this, okay, so for `YES'`, it is taking the negation of `SELECT` for `B`, along with this, I’m using AND. Okay, `A` and `YES`. Here also, in between this, I’m using OR. So, that is bitwise—you have to use bitwise operations. Okay, so using these operators, we can write the design for different...
In the sensitivity list, so now you can see here: For S equal to 1, I’m getting Y equal to 1. For the next value also, if there is a change in A, yes, the value also—it is not changing. The output has remained the same. Why? Because, in the code, in the always block, it is not depending upon the Y value. It is only depending upon the A and B values. Okay? This is wrong, right? So, for that sake, always you have to complete the sensitivity list. Okay? Have you understood this? Yes, ma’am. Yeah, ma’am. Okay.
Okay, okay, okay. Uh-huh.
Okay, okay. Uh-huh.
Okay, okay, okay. Uh-huh.
Okay, okay. Uh-huh.
Okay, okay. Uh-huh.
Okay, okay, okay. Uh-huh.
Okay, okay.
Okay, okay. Uh-huh.
Okay, okay, okay. Uh-huh.
Okay, okay, okay. Uh-huh.
Okay, okay, okay.
So, for the PMOS, we have VDD, IN, and OUT. And for the NMOS, we have INPUT, IN, GROUND, and OUT. Here, VDD is the source, IN is the gate, and OUT is the drain for the PMOS. For the NMOS, the source is GROUND, OUT is the drain, and IN is the gate. To understand this, you have to go back to your basics of VLSI and understand it. Okay, so if we have a PMOS and an NMOS connection, whatever input I give here will be inverted. This is the inverted diagram using PMOS and NMOS. Okay, so now, how do we write a Verilog code for this? How will we write it?
I can assign `a` equal to 1, `a` equal to 0, like that. But if it is of multiple bits, then you have to define it like `2'b00`, like that. Okay, so for a single bit, you can either write directly `a = 1`, `a = 0`, or you can use a format like this: `1'b0`, `1'b1`. Okay, but for multiple bits, you cannot write like this directly. You have to define it for multiple bits, like if it is two bits, `2'b00`, `2'b01`, okay. Those values you have to mention. So this is the test bench for the inverter. Okay, any doubts in this? Yeah, Prabhat. Ma'am, just a little doubt—if I took the input as `a` in vector form, like `4 downto 0`, so input in the vector form means which... which...
So, sorry, this is `n1`, and this is `n2`. Okay. So for this `n1`: `s1` is the ground, `b` is the gate. Okay. So the drain is `a`, `s1` is the ground, `a` is the source, and `b` is the gate. So drain, source, and the gate. For `n2`, the next one: the drain is `out`, `s1` is the source, and `a` is the gate. Next, for the PMOS: the drain is `out`, the source is VDD, and the gates are `a` and `b`. Okay. So this is for a NAND gate. So if you want to write a NAND gate, what you have to do is connect an inverter here. Okay. So this will be your NMOS, and this is your PMOS. So here, it will be having...
And this is a ground. So, at that time, what will happen to this `out`? Okay. It will become an intermediate signal. So, for that reason, we will declare this `out` as a `wire`. Here, I will name it as a `wire`. Okay. A `wire` is the output, so this `out` will become a `wire`, along with `s1`. `Out` will become a `wire`. So, this is the NAND gate. Here, this NAND gate, along with one inverter, will give you an AND gate. Okay. So, again, in the AND gate, you have to add one more NMOS and one more PMOS here in the code. Okay. So, this is a NAND gate. Can I explain both the NAND and AND gates? Next, I have no. Okay. Now, I want...
After that, we did it. Yeah, okay. For the next PMOS—for the next PMOS—why? Okay. Why? Yes, `s1_b`. `s1_b`. So, now, in this case, `s1` will become the drain for the first NMOS. For the second PMOS, it will become the source. Okay. Then, what about the NMOS? The NMOS are a source—it will become a white ground. Honey, yeah. Okay. For the next time, it will become white ground. Honey, white ground—and meat. Okay. So, I'll just show the code now. So, here: `module not`...
These things, okay. So, here—if I change anything—okay. So, if I did not give `supply_one` again, and if I run it, ma'am—is it in the waiting room? What is in the waiting room? Okay. So, I'm not able to see here. Okay. Yeah, okay. So, if at all—if I miss something like `supply_one`—so again, it will tell that there is a problem with `VDD`. Okay. So, you have to give `supply_one` here. Sometimes, you may miss this one. If you give any other name, like instead of `ground`, if you give something like `zero` or something, these things will show...
So, here, I will define a four-bit value: `3 downto 0`. Okay. So, when I'm giving the value for `a` here, `a` will be equal to `4'b0001`. So, this is in binary. If you want to give it in decimal, `a` is equal to `4'd5`. Okay. So, if you want to give it in hexadecimal, `a` equals `4'hX` (any value like `4` or anything). If you want to give it in octal, `a` equals `4'oX` (any value). So, these are the different types you can write, but you have to define how many bits it is. Yeah, ma'am. Okay. So, guys, understood? Any doubts?
And, and, or. Okay, so anyway, you know the diagrams, so you can write for AND, NOR, and OR. Okay? So, in the assignment, those questions are not there. I want you to try for the switch-level implementation. Okay? So, we'll go back to the theory. We'll start with the operators. So, the operators—those are the...
That will indicate which operation has to be done. Okay, so the operators are used to build expressions, and they will describe the behavior of the hardware. We have different types of operators in Verilog. Here, we have logical operators, reduction operators, relational operators, shift operators, replication operators, bitwise operators, arithmetic operators, equality operators, concatenation operators, and conditional operators. These are the different operators. We'll see them one by one. First, I will go through the logical operators. The logical operators will produce a single-bit value. Okay, so after performing the operation, it will give a single-bit value. The single-bit value can either be `0`, `1`, or `X`. So, that represents a false condition, true, or unknown. Okay, so these are the symbols and the operations. So...
Double emphasis means it is a logical AND. Double pipe (`||`) means logical OR. The tilde (`~`) symbol is the negation. Okay, so for these things, first, logical AND and logical OR require two operands, and for negation, I need only one operand. So we have an example here. In the logical operators, if I give a four-bit value—consider this example. Just a minute; I will explain. So in this example, `a` is a four-bit value: `1101`, and `b` is `0000`. Okay, so in the logical operators, it will check. What is the value of `a` in decimal? How much is it? Ten, thirteen, thirteen, thirteen—it is.
If it is `X`, it is considered as an unknown value. So any operation with an unknown results in an unknown. The result will be unknown. Okay, so I have one more example here, which he asked. So here, that is `1101`, which is `1` for `b`, and it is `0010`. So here also, it is `1`. If I take the AND operation, it is true. Okay, so now, let’s move to negation. Next is negation of `A`. Okay, so what about the value of `A`? `A` is `13`, which is greater than `0`. So it will become `1`. What about the negation of `A`? It means it is the inverse of `A`. So the output will be `0`, which is false. Okay, so this is how logical operators work. Any doubts about these operators?
So, next is the reduction operator. In the reduction operator, you will have the same operators: AND, negation, OR, negation, or like this (NOR), okay. You should not confuse these operators with others, such as the double ampersand (`&&`) for logical AND or the single ampersand (`&`) for bitwise AND. Now, again, you have a single ampersand (`&`). Here, the operands should be noted: in this case, there is only one operand, but for logical AND and bitwise AND, you have two operands. That is the difference. Okay, so for the reduction operator, you have a single operand. Okay, so how does it work? Here, you have an example: `a = 1101`. So, the...
It will be a single bit. Okay. So, if I give a reduction AND (`&`) on `a`, okay, what it will do is it will operate within those bits. Okay. Recursively, it will perform the operations. So, it will start from the right side. Okay. So, if I have a reduction AND, such as `1 & 1 & 0 & 1`, what it will do is first it will do these two ANDs—`1 & 1`—which is `1`. Again, `1 & 0` will give `0`. Again, `1 & 0` will give `0`. So, the output will be `0`. Similarly, for the negation OR (`|`), if I have `0 | 1`, it is `1`. `1 | 1` is again `1`. `1 | 1` is `1`. So, it will start from the right side. Bit by bit, it will perform the operation and produce a single bit value. Okay. Logical operators also give you a single bit. Reduction operators also give...
Result in `x`, okay. So, either it will give `true` or `false`, okay. If I take an example, here, we have logical equality, which is `==` (double equals). Logical inequality is `!=` (exclamation mark with equals). Then, I have case equality, which is `===` (triple equals). Case inequality is `!==` (exclamation mark with double equals), okay. So, these are the operators, and the operands are two, okay. If I take an example, consider `a = 01x`, `b = 111`, and `c = 01x`. If I take `c == a` (logical equality), since `c` and `a` both have `x` values, okay, it will not compare them. It will result in `unknown`, okay. So, if I take `a === c` (case equality), then it...
You have a right shift and a left shift. So, I want you guys to check with the arithmetic shift in Verilog, okay? So, for your assignment, you have to check whether there is an arithmetic shift in Verilog or not. Yes, ma'am. Verilog does have it. Yes, it is there. But I want you to check in their tools, okay? Tomorrow, I want anyone of you to explain that, okay? Arithmetic shift in Verilog. So, if you don't understand, I will explain. Okay. So, for the arithmetic shift, you'll be having...
Equal to `1`, at that time, I should get `A`. If `S` is `0`, I should get `B`. Means, you will get this equation: Whenever the select line is `1`, `A` will go as the output. If the select line is `0`, `B` will go as the output. Yes, Ruchitin, ma'am, can you repeat it once again? Okay, so in the conditional operator, you have a syntax. You have to give the condition. Then, if it is true, the true value will go to the output. Okay, so if it is false, the false value will go as the output. So, in the 2-to-1 multiplexer, you have the `S` value. When `S` is `0`, okay, so when `S` is `0`, I will consider my output as `OUT`. The output is `OUT`, so I will get it as `B`. If I consider it like that, if `S` is `1`, okay, so that...
Sonal is in waiting. Okay, okay. So, when I do this one, okay? So, this negation of C, I will consider it as Z. Any value, okay? So now, this Z is performing some operation with B. So, B in the bracket, Z has come, plus A. Okay. Now, A plus B of Z means these two operations—it will do. So now, it is a multiplication, so I will get some value as X. Then, it is A plus 6, so I will get it as Y. So, Y will be my final output. So, the first priority is given to the brackets—whatever operation is inside those brackets will be done first. The priority is given to the operations outside the brackets afterward. This is the precedence.
Ma'am, yeah. In this context—in Verilog—we go from left to right or right to left. So, you are asking about the order of operations, yes, ma'am. Suppose we have multiple operations. Okay. Can you give me an example, like `y =`—okay, like `2 +`—means `2 + (3 / 5)`, anything, ma'am? Right? Yes, ma'am. So, we go from right to left or left to right. Actually, these two are performed first. Nope—in some cases, in C programming or something similar, I think we go from left to right. That's why I'm asking. In Verilog, so in Verilog...
I think the first equation and later bitwise operations are, I think, like in the table as well. That was in there, no? What he's asking is, if I have something like this: `-20 / 5`, okay. So `p2 = -20`, so here, yes, ma'am, it's the subscription operation. So here, it's arithmetic again. Where is arithmetic on top of unary? It's unary, so you have unary minus and plus. Yeah, what about subtraction and addition below the automatic multiply? Only moments there: binary minus, binary minus, and plus. So, according to this table, if I go this way, this will be done first, okay. It is divided by five, okay. Yeah, divided by five, okay. So, if I go according to this, `20 / 5` is done first.
For ALL—yes. No, one more thing: I will make it here as `1`. Okay. So now, I will make it as `AND`. Then, it will take `X`. Yeah, that only. `1` with `X` will take it as `X`. Yes, ma’am. Because the `N`-digit is enabled with `1` only, so the output will depend on the second input, `X`. Yeah, yes, ma’am. Okay. Only for `0`, it will give it as `0`. Okay. So, which one again did we want to do, ma’am? For this, ma’am, we don’t need to write a separate design and test, ma’am. No, no, no. It is just verifying the operators. No, so it will not mean providing the waveform or anything like that. So, if you want the waveform anyhow, you have an `initial` block here. So, just a minute—I will...
If `a` is `4'b1100`, no, no—from here, I have already moved `3'd0`. I’ve just considered `a`, `e`, and `c`. Okay, mhmm. So, now, if you do it like this, I told her that it may take the LSB value, or it will show a warning or an error. As I know, it will take the LSB value. See, it will take only the LSB value. Okay, if you write it like that, mhmm, so it will take only the LSB value and perform the operation. Okay. So, one more thing we wanted to check: Which one is that? Logical—Which one? I think logical operators.
So, where is that web form? We'll remove it. We'll see the result. Oh, just a minute. I have changed it here. So, I will comment out other things. I will take only the first one.
Right. For logical AND and all that—logical and bitwise—we took no precedence. Precedence—I have to check. So, `a + b`—tell me some equations. Multiply it by—don’t put in brackets. Ma’am, don’t give in brackets. Okay? Yes, ma’am. Yeah. Mhmm. Multiply it by `c`. Multiply it by `2`. Minus some value. Divide it. Value of `a` is `7`. Value of `b` is `8`. Okay? Multiply by `2`—there’s no problem. Again, take the values in decimal—it will be easier to calculate. Yeah, that will be `2 - 1`. I have taken. Mhmm. Okay. Now, divided by `4`. Divided by `6`. Okay?
Okay, if I start from the right: `1` divided by `6` is `0`. That is right. That is right. `7` plus `16` is `23`. Yeah, minus `0`. From right to left, going from right to left—I mean, some right to left. Right? Yes, ma'am. Yeah, right to left or left to right. Right to left. To left. `1` divided by `16` first is `0`. So, `1` divided by `6` is `0`. Right? So, `2` minus `0` means `0`. `2`. `2`. So, `2` into `b`, `2` into `a`. `2` is `a`. `16` plus `7` is `23`. `23`. Using a higher divide operator—not a modulus operator. Yeah, it is.
I'm... I'm... I'm... I'm... I'm...
So, which one do I have to check next? Arithmetic. Arithmetic—you will check and come, or we'll see here itself. Okay, we will—we'll do it by ourselves, and we'll check it. Yeah, you do it by yourself. You check it, and tomorrow, anyhow, in the class, we'll open this and we'll check it. Okay, tomorrow we have a class, ma'am. Why? What, ma'am? I have a doubt. Saturday? Saturday—I don't know. Not Saturday—it is Monday. Okay, okay. We'll be having class on Monday, ma'am. I have a doubt. Yeah, so I was telling that if we consider it from right to left and if we consider the precedence order, so we should do the division first, right? So, if you do the division first, the answer is not five. So, `8` divided by `2` will be `4`. `1` divided by `2`—which is `8` by `2`—which is `4`. `4` minus `3` is `4` minus `1`, which is `3` minus `6`. No, `4` minus `1`, which is `3`. Three...
Be wired by default in gate-level and structural modeling. Also, it remains the same when you go to dataflow modeling—it is the same. Outputs and inputs will remain as `wire` type. When you go to behavioral modeling, the output should be of a `reg` type. Okay. So, any doubts in today's session? Please tick mark "Yes" or "No," ma'am. Yeah, ma'am. Suppose we are taking a full adder in the dataflow model. Okay, so in intermediate connections, sir, should be mentioned as wire connections—wires, wire. Okay, yeah, wires. So, if you do any connection between the gates, no—that should be of a `wire` type.
Instead of `design.v`, I have used it as an instance only. So, again, you are creating it like this. Yeah, yeah—that's why I didn't use the `design` one, `design.v`. You did not use this one, `design.sv`. Okay, so actually, now the tool will compile like this: First, it will go to `testbench.sv`. Inside that, it will check which model is there. Then it will go to this design. In the design, if you don't write anything, it will go to the next one. Okay? So, usually, in `design.sv`, you have to write the main code. The sub-codes you write like opening new tabs here. Okay? I think now it got cleared. Yes, ma'am. Yes, ma'am. Okay, so let us continue with the theory session. So, today's assignment—I have asked you to enable. Okay, today, you'll be having an assignment based on the...
Okay, okay, okay. Uh-huh.
Okay, okay.
Just a minute. Okay, if you've written the code like here, then if you want to open a new one, you have to click on the left side to start a new playground, and again, you'll get a new one. You have to write something like "design.sv." You can't close it if you want a new file to be added to that one. Whichever file is there, you have to click the plus symbol.
Okay, for the structural approach, you need two extra files because some models will be involved. At that time, the main code has to be written in `design.sv`. Here, the plus symbol is available, and using that, you have to create something. Maybe you think that in `design.sv`, you've written about the full adder. So, if the full adder uses a half adder, you need to write the half adder code. Click here and create a `.v` file. Here, you have to write the half adder code. You cannot close `design.sv` and `testbench.sv`; those are fixed. Any doubts? Again, no, ma'am. Actually, I have done something like creating a new tab for the next step. That's right; a new tab means something like this. They are using "new" instead of "design."
Okay, you.
Oh, God. So, I will open the codes here—just a minute.
Okay, so I have examples here. So, inverter switch-level, okay? Here, in the design, I have a module `inverter(y, a)`. Then, I have `input a`, `output y`, `supply_one vdd`, and `supply_zero ground`. You can see that the keywords are shown in purple. Then, I have a PMOS `p1(y, vdd, a)` and an NMOS `n1(y, ground, a)`. Here, I have a testbench for the inverter. So, in the testbench, the inverter is instantiated. Then, I have an `initial` block where `dumpfile` and `dumpvars` are done. I'm giving `a` values, and after some time, I'm displaying again.
So, I am giving a value, adding some delay, and displaying the values. Then, I am changing the value of `a` again and displaying it. So, then `$finish`. If I run this, okay, you’ll see some errors. Okay. What it is doing—I have to change the tool. Okay, save and run it. So, it is showing some errors. It says "unidentified `b_testbench.sv`" because I have given `b` here, but that variable is not present. So, I will comment it. After that, if I save and run it...
So, in the waveform, you'll get the value of `a` and the value of `y`. When `a` is zero, `y` is one. When `a` is one, `y` is zero. Okay. When `a` is zero, `y` is one. So, here—in this one—just a minute. Just talking—not able to...
Okay, so I wanted to show you this one. I will remove the waveform. So, see here—the initial value of Y. I did not give any delay here. Okay? Directly, I wrote the display statement. Okay? The value of A will show, but the Y value—the updated Y output of the inverter—is showing X in the display. Okay? This is why, because there should be some delta time. Okay? So...
Initially, it will be like this—you won't be having anything. Okay, so what I will do is, anyhow, `testbench.sv` will be fixed. So you have to start writing the code. For the inverter test bench, I will write `inverter_tb;`. The syntax we saw in the previous class. I have a `reg a`, then I have `wire y`. Then we have to do the instance of the inverter of the design model. So what I will do is `.y(y)` for the connections, then I have `a(a)` for the input and output port mapping. Then I will write `initial`, and I have `begin`. Then I will use `$dump` in order to get the waveform.
Two times six is eighteen. No, you have to perform `1` into `6` also. `1` into `6`. `1` into `6`—you also have to do that. Oh, okay. Okay, I got it. Yeah, okay. Yeah, so we'll continue with the theory. No operators. Any doubts again? No, ma'am. Okay, so I will go back to the slides. We'll take a break. So now, it is eleven forty-five. We'll come back at twelve. Okay. Okay. I...
I’m... I’m... I’m... I’m...
I... I... I’m... I’m... I’m...
I... I... I'm... I'm... I'm...
I’m... I’m... I’m...
I... I'm... I'm... I'm...
I'm... I'm... I'm... I'm... I'm...
I... I... I... I... I’m...
You're telling me about the four-bit triple adder, ma'am. So, for the four-bit triple adder, you will draw it using switch-level modeling. Uh-huh. No, ma'am, just a note: in the test bench, we have those connections. No, ma'am, this one—you're talking about the connections, right? Yeah, yeah. Okay. So, if you take the input in vector form, we need to use the connections as `.a[0]` and `.b[0]`, etc. No, no, no, no—nothing like that. So, for example, here—if you think of another example, let's say `a` is declared as a forbidden type. If you think of it as forbidden, yeah. So, anyway, you will declare it here as `0 to 3 a`. You'll define it here. And again, in the test bench, you'll define `a` as `0 to 3 a`, right? Yeah, ma'am. So, the...
I’m... I’m... I’m... Uh-huh.
I’m... I’m... I’m... I’m...
I... I'm... I'm... I'm...
I—I—I—I—I’m.
This is the code. So in this one, I have a module called `nand_gate`. So I have the ports here: `out`, `a`, and `b`. Then I have `input a`, `b`, and `output out`. So for the VDD and the ground, I’m using `supply1` and `supply0` for the ground. So I have a signal `s1` here—one connection that is in between the connection of the NMOS. So that is a wire. Okay, `wire s1`. So now, the order doesn’t matter. Okay, similar to your gate-level implementation—I don’t know—depending upon the input changes, the components will be activated. Similarly, here, in the switch-level implementation, the order does not depend. You can write the PMOS first or the NMOS second, or the PMOS first and the PMOS second. Okay, but the connections should be proper. The order—that is, drain, source, gate—should be correct. Okay. So I have an NMOS written first, so `n1`. So first is the drain, so this one is taken as the drain for `n1`. And this is...
Hello, guys! So, everyone is back. Please take my case. Alright, I will launch the poll, which will be regarding operators. Okay, answer it. It has some ten questions, so take ten minutes. Take the poll questions, answer the poll questions, which are on operators. Once you finish the poll, take Marquez.
I... I’m... I’m... I’m... I’m...
I’m—I’m—I’m—I’m—I’m.
I—I—I—I—I’m.
Get `y`. `a` and `b` are the inputs. The output is `y`. Then, I have a supply of `VDD` and a ground. In between this PMOS, `y`—yes, one is the wire. So, these are the connections. So, `y` to ground, `b` to ground, and `a` for the NMOS. For the PMOS, it is `s1`, `VDD`, and `a`. Then, for the second PMOS, it is `y`, `s1`, and `b`. So, for this, we have to write the test bench and check for the outputs. Okay. So, let me go to the tool.
I... I'm... I'm... I'm... I'm...
I... I'm... I'm... I'm...
I... I’m... I’m... I’m...
I’m... I’m... I’m... I’m... I’m...
For logical OR, I have `a = 1` because it is greater than zero. Then I have `b = 0`, so that is zero. It will do the logical OR, and it will give the result as `1`. Now, once again, can you please repeat the same thing? Same thing—I will repeat here. So, you have an `a` value that is `1 1 0 1`. Here, it is `13`. The `b` value is `0`, right? These values are compared with the zero value. Thirteen is greater than zero, so what it will do is, instead of taking a four-bit value, it will make it as a single bit—that is, `1`. If it is greater than zero, it will make it as `1`. If it is equal to zero, it will treat it as `0` only. Now, with this single bit, it will do the logical operation. So, `1` and `0`—I have taken logical AND, so `true` and `false` will give the result as `false`, which is `0`. Okay? Similarly, for the OR...
I... I... I'm so... Twenty-four of you have submitted.
Ocean. So, I have `a = 1101` and `b = 1100`. The operation is given as a **reduction XOR**, so it will be done from right to left. Zero XOR zero is zero. One XOR zero is one. One XOR one is zero. So, the answer is one bit: `0`. Okay. The answer is the second option.  

Next, we have a fifth question. This is a double line, which means it is a **logical OR** operation. So, you’ll get the answer in a single bit. Okay. What about `a` and `b`? `a` is `true`, and `b` is `false`. So, the result of the OR operation is `true`. Therefore, you have to answer it as a single bit: `1`. So, the answer is the second option. Some of you have written four bits, okay? But it is a logical operation, so logical operators will give the result in a single bit.
I... I... I'm... I'm... I'm...
I...
I... I... I... I... I'm...
The answer is the third: all zeros, eight-bit zeros. Then, the ninth question: one concatenation, so `b || a || a`. Okay, so `b` is three bits, and `a` is two bits. So, `3 + 2 = 5`, which makes it six or seven bits. So, the value will be of a seven-bit size. First, it is `a || b` here, so the MSB will be `b`, which is `01X`. Then, you have `a`, which is `01`, and another `01`. The answer is the second one. Okay. So, then, the tenth question: two times of `a`. So, you'll be having four bits: `01` and `01`. So, that is the second answer. Okay. So, these are the questions which are based on the operators. Just make a note of this operator, as it will be useful. Okay. So, there will be confusion only in that: logical reduction versus bitwise. You'll get confused for nine and size `C`, right? Seven bits: which one—nine or...
I—I—I—I—I’m.
Uh-huh, okay. So, we'll take this up in the next session. I will share this PPT. Next, you have data flow modeling. Okay, so in data flow modeling, we will be using operators, and you'll be using the `assign` keyword. Okay. So, in data flow modeling, you should know the equations. The data flow models are developed by using the equations that represent the design. In data flow modeling, you'll be using some conditional expressions. Those conditional expressions will act as switching controls. And here, you'll be using the `assign` statement.
So, we'll take up this example. It's the same thing: a 2-to-1 multiplexer. As I explained using the conditional operator, I will have a module, the module name, then the port list. Then, I have inputs and outputs. Okay, so then I have the `assign` keyword. When you are writing dataflow modeling, the `assign` keyword is used. Then, I have `y = (yes ? a : b)`. If `yes` is true, I will get it as `a`; otherwise, I will get it as `b`. Okay, so in dataflow modeling, we'll be using `assign` statements. This `assign` statement will be triggered or executed once there is a change in the values of the variables. Okay, so if you are having multiple `assign` statements—okay, for example, in different courses, you'll be using multiple `assign` statements. At that time, what will happen? All the `assign` statements will be executed in parallel, but...
Upon the input values, the change in the input values will trigger it. Okay, so let me take some other examples here. I have a half-adder. Okay, so this is my half-adder. Yeah, Gerald, even if `a` and `b` change, unless or until `yes` changes, the output won’t get reflected. No, in the previous code—for months, in the previous code, as soon as `a` and `b` change, you’re saying that `y` will get changed. No, ma’am. Yeah, it depends on the `yes` condition. No, so it depends on the `yes`. Here, I’m using the conditional operator, but in some codes, I can use XOR or NOT gates, and so, at that time, those operations and the result will trigger the `assign` statements. Okay, so first, it will do this operation using this `assign` statement. The value will be updated to this...
I am... I'm not into `a` or `b`. I know—you have to write the `b` component. Yeah, the complete equation you have to write later in the assignment statements using those bitwise operators. Okay, okay. So, there is no shortcut or something like that. No, we have to follow. Okay, okay. For adders, you have shortcuts because you have arithmetic operators there. Okay, okay. So, for marks, I think—can you use then? It is conditional operators. No, we can use conditional operators, ma'am. There are conditional operators you can use. Okay. After the question mark, we have to include another condition, and then... Alright, okay, okay, okay. Instead of a condition, you can use... Okay, okay, okay, okay. Otherwise, in between, you have to take some wire and some four conditional operators, and then you can use that. That is a special one. By another condition? No. Which one? Oh, Jerome is saying: After the question mark, we need to give you another...
So, in the data flow modeling, you are writing it as an `assign` statement. Okay. So, here, in the `assign` statement, you have to declare it as a `wire` in the data flow modeling. But in behavioral modeling, we have to write—you declare it as a `reg` type. The output should be declared as a `reg` type. So, inside this `always` block, we are assigning the `y` value. Okay. So, if you don’t declare it as a `reg` type, it will show an error like, “Procedural assignment is not declared as a `reg` type.” It is under a procedural block. So, here, the `y` output value is being assigned inside the `always` block, which is a procedural block. Okay. So, you have the `always` keyword. This is the `@` operator. Okay. `@` means it will wait until there is a change in these values. These values—whatever we call this—is called a **sensitivity list**. So, we call it as a...
Sensitivity, okay. Sensitivity list, okay. When you're writing this list, now here—the model on which it depends, on which input it depends—all the variables you have to write here. Okay. `a`, `b`, `s`—all the values you have to write. So, the MUX will depend on `a`, `b`, and `s`. It's a 2-to-1 MUX, so all the variables you have to define. If you miss one value, it will give a simulation error. Means, in the waveform, you'll get different values. Okay. And this `always` block—it will be executed whenever there is a change in these variables. So, initially, `a`, `b`, and `s` are the inputs. So, what is the default value? It will be of `wire` type, and it is having a `'Z'` value, right? Once this value changes to like `1'01` or something, okay, then...
This `always` block will get executed. So, again, inside this, you will have an `if-else` or a `case` statement. Then, you have an `end` for this `always` block, and `end` for the `endmodel`. So, if at all you miss one of these, okay, you will have only `a` and `b`. If you don't give `yes` in the `always` block, okay, you consider `a` as `01`. Yes, initially, you have given `0`. Now, at the starting, there is a change in the `a` and `b` values, so it will get entered, and it will perform the operation. The next time, I will give `a` and `b` as the same value. I will change only the `yes` value. That time, as I did not give `yes`, it will not get entered into the `always` block. It will show the previous answer itself. Okay, so for that sake, you have to give all the ports in the input ports on which that...
Missy, as it is a single bit, I’m taking only the variable. Yes, if it is `1`, `y` will be `b`. Yes, `y` will be `a`. So, it is similar to your C programming `if-else`. Okay. So, this is how we’ll be writing the behavioral modeling. So, any doubts? No, ma’am. Okay. So, I will stop here. I will go to the tool, and I will show you what will happen if you miss any value inside it. Okay.
Okay, I have that code. Okay, so I will share the screen of that area playground. Okay, so I have a 2-to-1 mux. Input: `a`, `b`, `s`. Output: `reg y`. Always block: Initially, I will give all the values. Okay, so if `yes`, `y = b`; else, `y`...
So, in the test bench, I have given some values for `a`, `b`, and `s`. Okay. In the next step, after some time, I'm changing the `s` value. Okay. So, now, if I run this one—okay. So, I have here: `a` is `0`, `b` is `1`, so `s` is `1`. That means the output is whatever is there in `b`. So, when I see the next values, so when `s` changes to `0`, why is it changing? Right. So, now, if at all I change in the code—I will remove this `s`. Okay. So, I will run it. If I'm by mistake—if I forget to write the input...
In the sensitivity list, so now you can see here: For S equal to 1, I’m getting Y equal to 1. For the next value also, if there is a change in A, yes, the value also—it is not changing. The output has remained the same. Why? Because, in the code, in the always block, it is not depending upon the Y value. It is only depending upon the A and B values. Okay? This is wrong, right? So, for that sake, always you have to complete the sensitivity list. Okay? Have you understood this? Yes, ma’am. Yeah, ma’am. Okay. So, something you had asked—no, sorry, this `reg`—okay, so I will save it and run.
Flow in the test bench—you’ll use `initial`. In data flow, you’ll use `assign`. Sorry, `assign`—that’s it. Okay. Then, I will show that code as well. I need to go back again. So, let me take one example of data flow modeling. So, here, you have `assign` with the data flow modeling of a half adder. That I have given a single value of `a` and `b`. So, when I run this one...
As I’m using a `display` statement, I will get you here in the log file: `a` is `1`, `b` is `0`, `sum` is `1`, `carry` is `0`. So, if at all you remove this one—okay, directly if you do this—it will show an error: “Unexpected token,” “Undefined module `b` was used,” “Port connections rules will not be checked at such instance,” and all those things. Errors you will be getting. So, whenever you are using data flow modeling, you have to use the `assign` keyword. The test bench will remain the same for all the modelings. So, only in switch-level modeling do you not have any problem. Inputs will be `wire`, outputs will also...
I’m... I’m... I’m... I’m... I’m...
Yes, I see. Ninth question—ninth question, no, ma’am. Ninth question—mhmm. So, in the ninth question, you have B, A, A. So, B is 0'bx1, so that will be in the MSB part: 0'bx1. Then, you have A as 01, and again, A is 01. That is the third answer—seven bits. Seven bits—it is seven bits because B is three bits, A is having two bits, so three, four, five, and again, once again, A means another two, so it is seven bits. Okay, the answer is the third one. Okay, okay. So, I’ll stop sharing the results, sir—just a minute.
Y, okay, ma’am. Okay. Assigning the values, okay, ma’am. Okay. So next, again, you have a half adder. So, in the half adder, you have an XOR and an AND. So, here, in the half adder, I have an XOR and an AND. So, here, you have `a` and `b` as the inputs, and `s` and `c` as the outputs. So, when I take the XOR using the `assign` statement, `assign`, yes, this is XOR. So, I have a caret (`^`), so this is a bitwise operation. Okay, it is not logical—it is a bitwise operation. Because sometimes your inputs may be of three bits or four bits. So, that time, if you use a logical operation, you’ll get a single bit as output, which will be incorrect. So, here, you’ll be using bitwise operations. So, yes, for some, it is `a ^ b`. So, for `c`, it is AND, so...
One max, two is to one, `a`, okay. Yeah, `a` colon `b`, right? Next, `a` colon `b`, okay. This is for two is to one max. Yeah, so see here: If it is a single bit, directly you can write `yes`. If it is multiple bits, you have to use this one: double equals (`==`). That’s the case for equality. See, no, you have to use it. Okay, okay, okay. This is equal to, like we can write `s_not` and `s_one ?` Follow the column `b`, column `c`, column... No, no, no, no. Yeah, so this `yes` means it indicates that, as it is a single bit, directly we can write `yes`. So, if it is multiple bits, you have to use this equal symbol. Okay, okay. So, Roshan, ma’am, is there any shortcut process, ma’am? Like, for eight is to one max, it will be a lot more. So, eight is to one max means like three bits...
Modeling. So, behavioral modeling is the highest level of abstraction. Okay, so here, you should know the truth table. If you know the truth table, you can easily implement whatever specification you have given, and you can capture it in the code. Okay. Here, you'll be using the `always` block. So, here, like this, you'll be using this as an example of a 2-to-1 mux. So, here, in behavioral modeling, you will have an `always` block. Inside this, you'll have conditional statements. Okay. So, this `always` block is also called a procedural block. `Initial` and `always` will come under procedural blocks. So, till now, what we did: We saw assignment statements. We saw primitives using the primitive gates. We saw then we saw primitive transistors using that, and we did switch-level modeling. Gate-level and structural-level modeling were done, and in dataflow modeling, we used `assign`. So, when we go to behavioral modeling, we have procedural blocks, which is using...
The module will depend on how you view the sensitivity list. So, the coding guidelines for Verilog, when you work with behavioral modeling, are that you have to include all the inputs in the sensitivity list. The sensitivity list must be complete. Okay. Have you understood this? Any doubts? Ma’am, why do we take a `reg` type for the output, always a `reg` type? It is because, in behavioral modeling, here, this `if` statement—okay, so here, this `y` value is not connected to any gates. It is not driven by gates. We are using the truth table and writing it here. Yes, ma’am. It is not driven by gates. Okay. So, we declared it as...
